<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Extending Ruby</title>

  <link href="./assets/style.css" rel="stylesheet" />
</head>

<body>
  <header><h1>Extending Ruby</h1></header>
  <main>
    <p id="date"><b>2025-05-20</b></p>
    <h2>Introduction</h2>

<p>Ruby is a great programming laguage, known for its developer friendliness and fast development.
Unfortunately that comes with a performance cost, although with its recents improvements, like the native Ruby parser
<a href="https://github.com/ruby/prism">PRISM</a>, or using Rust on its just in time compiler <a href="https://github.com/ruby/ruby/blob/master/doc/yjit/yjit.md">YJIT</a>.</p>

<p>However, there are times when you have to push the performance further, like adding <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a>,
or maybe there&#39;s a library with C binding, like <a href="https://github.com/raysan5/raylib">raylib</a>, 
or even integrating with Large Language Models, and extending Ruby can be the perfect solution.</p>

<p>The Ruby MRI (Matz&#39;s Ruby Interpreter or CRuby) implementation provides a C API to extend its capabilities.
There are two ways of extending Ruby, an easier approach using <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">FFI</a>, 
or compiling and loading a <a href="https://en.wikipedia.org/wiki/Shared_library">shared library</a>
for more control.</p>

<p>This post will focus on the compilation method to create C extensions for Ruby on <a href="https://stallman-copypasta.github.io/">GNU/Linux</a>,
by first creating a simple adder class, and then wrapping raylib to create a <a href="https://github.com/raysan5/raylib/blob/master/examples/core/core_basic_window.c">simple window</a>.
Every example was created using Ruby <code>3.4.3</code>, other versions may not work!.</p>

<h2>Let&#39;s Add</h2>

<p>First and foremost, we have to be confortable with reading and writing C,
and then, get familiar with the <a href="https://docs.ruby-lang.org/en/master/extension_rdoc.html">C API</a>.</p>

<p>Every extension should be located in the <code>./ext/&lt;extension_name&gt;/&lt;extension_name&gt;.c</code> directory.
Knowing that, lets create the directory structure and the file needed.</p>

<pre><code class="shell">$ mkdir -p ./sum/ext/sum &amp;&amp; \
    cd sum &amp;&amp; \
    touch ext/sum/sum.c &amp;&amp; \
    tree
.
└── ext
   └── sum
       └── sum.c

3 directories, 1 file
</code></pre>

<p>Now open your favorite editor and add these contents to the <code>sum.c</code> file.</p>

<pre><code class="c">#include &lt;ruby.h&gt;

static VALUE add(VALUE self, VALUE a, VALUE b) {
  return RB_INT2FIX(RB_FIX2INT(a) + RB_FIX2INT(b));
}

void Init_sum(void) {
  VALUE sumClass = rb_define_class(&quot;Sum&quot;, rb_cObject);
  rb_define_singleton_method(sumClass, &quot;add&quot;, add, 2);
}
</code></pre>

<p>Wow! that&#39;s a lot of weird stuff!<br>
Lets break down the file in parts so we can understand what&#39;s happening.</p>

<p>The <code>#include &lt;ruby.h&gt;</code> allows the usage of the Ruby C API, so we can interact with Ruby within our
C code.</p>

<p>Let&#39;s analyze the <code>add</code> function:</p>

<ul>
<li><p>The <a href="https://github.com/ruby/ruby/blob/d0b7e5b6a04bde21ca483d20a1546b28b401c2d4/include/ruby/internal/value.h#L40"><code>VALUE</code></a>
is an <code>uintptr_t</code>, an unsigned integer that can be used as a pointer, and it represents a Ruby Object,
so it could be an Integer, Array, File, etc...</p></li>
<li><p>The <a href="https://github.com/ruby/ruby/blob/d0b7e5b6a04bde21ca483d20a1546b28b401c2d4/include/ruby/internal/arithmetic/int.h#L129"><code>RB_FIX2INT</code></a>
is a function that converts a <code>VALUE</code> to a C Integer.</p></li>
<li><p>The <a href="https://github.com/ruby/ruby/blob/d0b7e5b6a04bde21ca483d20a1546b28b401c2d4/include/ruby/internal/arithmetic/long.h#L111"><code>RB_INT2FIX</code></a>
is a function that converts a C Integer into a <code>VALUE</code>.</p></li>
</ul>

<p>So the <code>VALUE add(VALUE self, VALUE a, VALUE b)</code> function receives two Ruby objects (<code>VALUE a</code> and <code>VALUE b</code>),
converts them to C Integers, adds them, wraps the result into a <code>VALUE</code>, and then returns it.</p>

<p>Finally, let&#39;s analyze the <code>Init_sum</code> function:</p>

<ul>
<li><p>The function <code>void Init_sum(void)</code> is the entrypoint of our extension. It should always be named like
<code>Init_&lt;extension_name&gt;</code>.</p></li>
<li><p>The <a href="https://github.com/ruby/ruby/blob/c52f4eea564058a8a9865ccc8b2aa6de0c04d156/class.c#L1481"><code>rb_define_class</code></a>
function is used to create a class Object in Ruby, it expects the name of the class, and its superclass.
Every object <strong>must</strong> have a superclass.</p></li>
<li><p>The <code>VALUE sumClass = rb_define_class(&quot;Sum&quot;, rb_cObject);</code> creates a class <code>Sum</code>, with a superclass
<a href="https://github.com/ruby/ruby/blob/d0b7e5b6a04bde21ca483d20a1546b28b401c2d4/include/ruby/internal/globals.h#L68"><code>rb_cObject</code></a>
that references to <code>Object</code> in Ruby, and then stores the Ruby class into <code>VALUE sumClass</code>.</p></li>
<li><p>The <a href="https://github.com/ruby/ruby/blob/c52f4eea564058a8a9865ccc8b2aa6de0c04d156/class.c#L2820"><code>rb_define_singleton_method</code></a>
is used to create an <code>add</code> singleton method for the class <code>VALUE sumClass</code>.</p></li>
</ul>

<p>All of that to would be the same in Ruby as:</p>

<pre><code class="ruby">class Sum
  def self.add(a, b)
    return a + b
  end
end
</code></pre>

<p>Now, how do we run this C file? Easy, we need to compile it into a shared library!</p>

<p>Ruby have a module (<a href="https://docs.ruby-lang.org/en/3.4/MakeMakefile.html">MakeMakefile</a>) that provides a
DSL to create a Makefile and compile our extension into a shared library. Let&#39;s create <code>ext/sum/extconf.rb</code>.</p>

<pre><code class="ruby">require &#39;mkmf&#39;

create_makefile &#39;sum/sum&#39;
</code></pre>

<p>Since our this example is very simple, there is no need to add more options to compile this extension.
To generate the Makefile, we need to run the <code>extconf.rb</code></p>

<pre><code class="shell">$ ruby ext/sum/extconf.rb &amp;&amp; \
    tree

creating Makefile
.
├── ext
│   └── sum
│       ├── extconf.rb
│       └── sum.c
└── Makefile

3 directories, 3 files
</code></pre>

<p>That will create the Makefile in the current directory. Now we just need to compile using <code>make</code>. The
Makefile will create two files in our current directory, <code>sum.o</code> and <code>sum.so</code>. Only the <code>sum.so</code> is
important for our needs.</p>

<pre><code class="shell">$ make &amp;&amp; \
    tree

compiling ext/sum/sum.c
linking shared-object sum/sum.so
.
├── ext
│   └── sum
│       ├── extconf.rb
│       └── sum.c
├── Makefile
├── sum.o
└── sum.so

3 directories, 5 files
</code></pre>

<p>Done. We created our first C shared library that can be used directly in Ruby!
To use the <code>sum.so</code> it only needs to be required as <code>require_relative &#39;sum&#39;</code>. Here is an example</p>

<pre><code class="ruby">require_relative &#39;sum&#39;

Sum.add 2, 3 # =&gt; 5
</code></pre>

<h2>Windows Time</h2>

<p>Time for a more complex task, building a window using raylib. First we need to 
<a href="https://github.com/raysan5/raylib/wiki/Working-on-GNU-Linux">build it</a>,
then, let&#39;s create the directories and files needed.</p>

<pre><code class="shell">$ mkdir -p raylib/ext &amp;&amp; \
     cd raylib &amp;&amp; \
     touch ext/raylib.c ext/color.h ext.color.c ext/extconf.rb window.rb &amp;&amp; \
     tree
.
├── ext
│   └── window
│       ├── color.c
│       ├── color.h
│       ├── extconf.rb
│       └── window.c
└── window.rb

3 directories, 5 files
</code></pre>

<p><code>ext/window/color.h</code></p>

<pre><code class="c">#include &lt;ruby.h&gt;
#include &quot;raylib.h&quot;

VALUE color_initialize(VALUE self, VALUE red, VALUE green, VALUE blue, VALUE alpha);
Color get_color(VALUE colorObj);
VALUE init_color(VALUE super);
</code></pre>

<p><code>ext/window/color.c</code></p>

<pre><code class="c">#include &quot;color.h&quot;

// Same as:
// class Color
//   def initialize(red, green, blue, alpha)
//     @red = red
//     @green = green
//     @blue = blue
//     @alpha = alpha
//   end
// end
VALUE color_initialize(VALUE self, VALUE red, VALUE green, VALUE blue, VALUE alpha) {
  rb_iv_set(self, &quot;@red&quot;, red);
  rb_iv_set(self, &quot;@green&quot;, green);
  rb_iv_set(self, &quot;@blue&quot;, blue);
  rb_iv_set(self, &quot;@alpha&quot;, alpha);

  return self;
}

// Helper function to build a Raylib Color struct from ruby Color class
Color get_color(VALUE colorObj) {
  Color color;
  color.r = (unsigned char) NUM2UINT(rb_iv_get(colorObj, &quot;@red&quot;));
  color.g = (unsigned char) NUM2UINT(rb_iv_get(colorObj, &quot;@green&quot;));
  color.b = (unsigned char) NUM2UINT(rb_iv_get(colorObj, &quot;@blue&quot;));
  color.a = (unsigned char) NUM2UINT(rb_iv_get(colorObj, &quot;@alpha&quot;));

  return color;
}

VALUE init_color(VALUE super) {
    VALUE colorClass = rb_define_class_under(super, &quot;Color&quot;, rb_cObject);
    rb_define_method(colorClass, &quot;initialize&quot;, color_initialize, 4);

    // Creating attr_acessor :red, :green, :blue, :alpha for our Color class
    rb_define_attr(colorClass, &quot;red&quot;, 1, 1);
    rb_define_attr(colorClass, &quot;green&quot;, 1, 1);
    rb_define_attr(colorClass, &quot;blue&quot;, 1, 1);
    rb_define_attr(colorClass, &quot;alpha&quot;, 1, 1);

    return colorClass;
}
</code></pre>

<p>We could have wrapped the <a href="https://github.com/raysan5/raylib/blob/8d9c1cecb7f53aef720e2ee0d1558ffc39fa7eef/src/raylib.h#L247">Raylib Color struct</a>
into a <a href="https://docs.ruby-lang.org/en/master/extension_rdoc.html#label-C+struct+to+Ruby+object"><code>TypedData_Wrap_Struct</code></a>,
but for simplicity, we&#39;ll use the helper function <code>Color get_color(VALUE colorObj)</code>
to build a Color struct from the <code>Raylib::Color</code> class.</p>

<p><a href="https://github.com/ruby/ruby/blob/87d340f0e129ecf807e3be35d67fda1ad6f40389/variable.c#L4799"><code>rb_iv_set</code></a>
sets an instance variable, in that case, sets <code>@red</code>, <code>@green</code>, <code>@blue</code>, and <code>@alpha</code>.</p>

<p><a href="https://github.com/ruby/ruby/blob/87d340f0e129ecf807e3be35d67fda1ad6f40389/variable.c#L4788"><code>rb_iv_get</code></a>
gets the instance variable from a ruby class.</p>

<p><a href="https://github.com/ruby/ruby/blob/d0b7e5b6a04bde21ca483d20a1546b28b401c2d4/include/ruby/internal/arithmetic/int.h#L185"><code>RB_NUM2UINT</code></a>
converts a Ruby <a href="https://docs.ruby-lang.org/en/master/Numeric.html">Numeric</a> into a C <code>unsigned int</code>.</p>

<p><a href="https://github.com/ruby/ruby/blob/87d340f0e129ecf807e3be35d67fda1ad6f40389/include/ruby/internal/method.h#L199"><code>rb_define_attr</code></a>
defines either an <code>attr_reader</code>, or <code>attr_writer</code>, depending on the flags passed to <code>rb_define_attr</code>.</p>

<p><code>ext/window/window.c</code></p>

<pre><code class="c">#include &quot;color.h&quot;
// color.h already includes ruby.h and raylib.h,
// so there is no need for include them here too

static VALUE init_window(VALUE self, VALUE height, VALUE width, VALUE title) {
  InitWindow(
    RB_FIX2INT(height),
    RB_FIX2INT(width),
    StringValueCStr(title)
  );

  return Qnil;
}

static VALUE set_target_fps(VALUE self, VALUE fps) {
  SetTargetFPS(RB_FIX2INT(fps));

  return Qnil;
}

static VALUE window_should_close(VALUE self) {
  return WindowShouldClose();
}

static VALUE begin_drawing(VALUE self) {
  BeginDrawing();

  return Qnil;
}

static VALUE end_drawing(VALUE self) {
  EndDrawing();

  return Qnil;
}

static VALUE clear_background(VALUE self, VALUE colorObj) {
  ClearBackground(get_color(colorObj));

  return Qnil;
}

static VALUE draw_text(VALUE self, VALUE text, VALUE posX, VALUE posY, VALUE fontSize, VALUE colorObj) {
  DrawText(
    StringValueCStr(text),
    RB_FIX2INT(posX),
    RB_FIX2INT(posY),
    RB_FIX2INT(fontSize),
    get_color(colorObj)
  );

  return Qnil;
}

static VALUE close_window(VALUE self) {
  CloseWindow();

  return Qnil;
}

void Init_window(void) {
  // Creating a Raylib module
  VALUE raylibModule = rb_define_module(&quot;Raylib&quot;);
  rb_define_singleton_method(raylibModule, &quot;init_window&quot;, init_window, 3);
  rb_define_singleton_method(raylibModule, &quot;set_target_fps&quot;, set_target_fps, 1);
  rb_define_singleton_method(raylibModule, &quot;window_should_close?&quot;, window_should_close, 0);
  rb_define_singleton_method(raylibModule, &quot;begin_drawing&quot;, begin_drawing, 0);
  rb_define_singleton_method(raylibModule, &quot;end_drawing&quot;, end_drawing, 0);
  rb_define_singleton_method(raylibModule, &quot;clear_background&quot;, clear_background, 1);
  rb_define_singleton_method(raylibModule, &quot;draw_text&quot;, draw_text, 5);
  rb_define_singleton_method(raylibModule, &quot;close_window&quot;, close_window, 0);

  // Creating a Raylib::Color Class
  init_color(raylibModule);
}
</code></pre>

<p><code>ext/window/extconf.rb</code></p>

<pre><code class="ruby">require &#39;mkmf&#39;

with_ldflags(&quot;-lraylib -lGL -lm -lpthread -ldl -lrt -lX11&quot;) { true }

create_makefile &#39;window/window&#39;
</code></pre>

<p><code>window.rb</code></p>

<pre><code class="ruby">require_relative &#39;window.so&#39;

RAYWHITE = Raylib::Color.new 245, 245, 245, 255
LIGHTGRAY = Raylib::Color.new 200, 200, 200, 255

Raylib.init_window 800, 450, &#39;raylib [core] example - basic window&#39;
Raylib.set_target_fps 60

while !Raylib.window_should_close? do
  Raylib.begin_drawing
  Raylib.clear_background RAYWHITE
  Raylib.draw_text &#39;Congrats! You created your first window!&#39;, 190, 200, 20, LIGHTGRAY
  Raylib.end_drawing
end

Raylib.close_window

exit 0
</code></pre>

<p>After compiling and running the <code>window.rb</code>, it should open up a window exactly as the
<a href="https://www.raylib.com/examples/core/loader.html?name=core_basic_window">example from raylib</a>.</p>

<h2>Wrapping Up</h2>

<p>TODO</p>

  </main>

  <footer>
    <p>2025 — Rodolfo V.</p>
  </footer>

</body>
</html>

